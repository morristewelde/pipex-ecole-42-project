open ()
	O_WRONLY: Open the file in write-only mode.
	O_RDONLY: Open the file in read-only mode.
	O_RDWR: Open the file for both reading and writing.
	O_CREAT: Create the file if it does not exist.
	O_TRUNC: Truncate the file to zero length if it exists (i.e., clear its contents).
	O_APPEND: Open the file in append mode; new data is written at the end of the file.

	examples 
		int fd = open("example.txt", O_WRONLY | O_CREAT | O_TRUNC, 0644);

access() 

	R_OK: Checks if the file is readable.
	W_OK: Checks if the file is writable.
	X_OK: Checks if the file is executable.
	F_OK: Checks if the file exists (without checking specific permissions).
	
	R_OK = 4;
	W_OK = 2;
	X_OK = 1;
	F_OK = 0;   // these are defined in fcntl.h

	example
		access("morris.txt", R_OK);
	access return 0 or -1 if 0 access permitted if -1 acess denied check


exec execvp execve . . .

	will replace the program that was running in the first place and execute what is passed through exec.
		return exec will not return anything unless there is something wrong in that case it will return (-1).

	exec : will always be followed by v (vector) or l (list).
		 - vector : if v that means the arg is passed as an vector (char *);
		 - list : is passed as list of args.

		P(path) : if p is added after v or l it will search for the path the program arg.
	  		e.g - execlp("ls", "ls", "-al", NULL);
	  			- execl("/bin/ls", "ls", "-al", NULL); if the p is lifted then we have to provide the absolute path.
		e (environmental variable) - if e is added we want to pass d/t set of environmental variable to the end of the arguments.
	

	
wait(NULL) will pause the parent process untill the child is done executing.
	- wait will reply -1 if error or no child to wait for anymore unless otherwise it will return the process id it has been waiting for.



getpid() -  will get the process id of the current id.
getppid() - will get the process id of the parent id. both doesnt take arguments.



N.B - if we use sleep() to kill (sleep) a child process then the child process will have differentt parent ID than the process id of the main process. AND it will execute after we exit the main function.

int fd[2];
pipe(fd) - pipe takes two int fd[0] is where the pipe would read and fd[1] is where it would write. 


DUP2
	- dup2(fd1, fd2); - Dup2 will not copy the content of in fd2(the file opened by open to give the fd2 value) to fd1.

	- dup2(fd1, STDOUT_FILENO); - this will redirect the things from STDOUT_FILENO to fd1 so instead of writing in the terminal using printf or write function now they will write to fd1. 
	
	e.g -  
		int main()
		{
			int fd1 = open("text1.txt", O_WRONLY | O_CREAT | O_TRUNC, 0644);
			dup2(fd1, STDOUT_FILENO);  // Redirect stdout to fd1
			printf("This will be written to text1.txt instead of the terminal.\n");
			close(fd1);
			return 0;
		}

		N.B - even after close(fd1)  the printf or write or anything which is writing on the terminal will be directed to fd1 not the terminal >>> b/c DUP2 has done the redirection.
			
			HOWEVER - if we close(1) || close(STDOUT_FILENO) then nothing will be printed and directed to fd1 becuse it has been closed.

CHMOD 0644 || 0777 || 0764 ... 
	
	read 4, write 2, execute 1 = all permision 7 (4 + 2 + 1);

	N.B - the  infront is telling the system the numbers are on octal not decimal. 