open ()
	O_WRONLY: Open the file in write-only mode.
	O_RDONLY: Open the file in read-only mode.
	O_RDWR: Open the file for both reading and writing.
	O_CREAT: Create the file if it does not exist.
	O_TRUNC: Truncate the file to zero length if it exists (i.e., clear its contents). has no effect on the permission of existing file.
	O_APPEND: Open the file in append mode; new data is written at the end of the file.

	examples 
		int fd = open("example.txt", O_WRONLY | O_CREAT | O_TRUNC, 0644);

access() 

	R_OK: Checks if the file is readable.
	W_OK: Checks if the file is writable.
	X_OK: Checks if the file is executable.
	F_OK: Checks if the file exists (without checking specific permissions).
	
	R_OK = 4;
	W_OK = 2;
	X_OK = 1;
	F_OK = 0;   // these are defined in fcntl.h

	example
		access("morris.txt", R_OK);
	access return 0 or -1 if 0 access permitted if -1 acess denied check


exec execvp execve . . .

	will replace the program that was running in the first place and execute what is passed through exec.
		return exec will not return anything unless there is something wrong in that case it will return (-1).

	exec : will always be followed by v (vector) or l (list).
		 - vector : if v that means the arg is passed as an vector (char *);
		 - list : is passed as list of args.

		P(path) : if p is added after v or l it will search for the path the program arg.
	  		e.g - execlp("ls", "ls", "-al", NULL);
	  			- execl("/bin/ls", "ls", "-al", NULL); if the p is lifted then we have to provide the absolute path.
		e (environmental variable) - if e is added we want to pass d/t set of environmental variable to the end of the arguments.
	

	
wait(NULL) will pause the parent process untill the child is done executing.
	- wait will reply -1 if error or no child to wait for anymore unless otherwise it will return the process id it has been waiting for.



getpid() -  will get the process id of the current id.
getppid() - will get the process id of the parent id. both doesnt take arguments.



N.B - if we use sleep() to kill (sleep) a child process then the child process will have differentt parent ID than the process id of the main process. AND it will execute after we exit the main function.


PIPE
	int fd[2];
	pipe(fd) - pipe takes two int fd[0] is where the pipe would read and fd[1] is where it would write. 


DUP2
	- dup2(fd1, fd2); - Dup2 will not copy the content of in fd2(the file opened by open to give the fd2 value) to fd1.

	- dup2(fd1, STDOUT_FILENO); - this will redirect the things from STDOUT_FILENO to fd1 so instead of writing in the terminal using printf or write function now they will write to fd1. 
	
	e.g -  
		int main()
		{
			int fd1 = open("text1.txt", O_WRONLY | O_CREAT | O_TRUNC, 0644);
			dup2(fd1, STDOUT_FILENO);  // Redirect stdout to fd1
			printf("This will be written to text1.txt instead of the terminal.\n");
			close(fd1);
			return 0;
		}

		N.B - even after close(fd1)  the printf or write or anything which is writing on the terminal will be directed to fd1 not the terminal >>> b/c DUP2 has done the redirection.
			
			HOWEVER - if we close(1) || close(STDOUT_FILENO) then nothing will be printed and directed to fd1 becuse it has been closed.


CHMOD 0644 || 0777 || 0764 ... 
	
	read 4, write 2, execute 1 = all permision 7 (4 + 2 + 1);

	N.B - the  infront is telling the system the numbers are on octal not decimal.


TERMINAL OUTPUT TO A FILE 

	> 	- overwrites (STDOUT only)  (STDOUT doesnt show in the terminal)
	>> 	- appends (STDOUT only) (STDOUT doesnt show in the terminal) 

	2> 	- overwrites (STDERR only) (STDERR doesnt show in the terminal) 
	2>> - appends (STDERR only) (STDERR doesnt show in the terminal) 

	&> 	- overwrites (STDERR & STDOUT) nothing is shown in the terminal
	&>> - appends (STDERR & STDOUT) nothing is shown in the terminal

	| tee		- overwrites (STDOUT only) and displays at terminal as well
	| tee -a	- append (STDOUT only) and displays at terminal as well

	|& tee		- overwrites (STDOUT & STDERR) and displays at terminal as well
	|& tee -a	- append (STDOUT & STDERR) and displays at terminal as well


ENVIRONMENT VARIABLE 

	- to set an environment variable we can simlpy use 
		e.g. - 
			
			 - VAR=testing_env_variable   //this will create env variable called variable

					this VAR will not be used by other programs to use the variable by other programs we have to use "export" before declaring the variable 

			- export VAR=testing_env_variable   //now it is saved temporarly in the session we are using.

				but to save it and make it permanent you can edit the .bashrc file from home directory and add

			- add VAR=testing_env_variable to .bashrc 
			
				then run on terminal 
					source .bashrc    // this will refresh the changes you made to .bashrc

			- to make variable saved for all users you can go to etc (cd etc) amd add variable to the "environment" file.
				
				cd ~
				cd etc
				add VAR=testing_env_variable to environment 

			unset VAR   // will delete environmental variable setted by export (will remove from session not from etc/environment file or .bashrc )


BIN  & PATH     - - - - BIN (Binary Directory)

	- when basially pass a command in the terminal e.g. ls it will search in all the directory of the path and execute the comand. or will reply "command not found"

	PATH = /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin

	This means the shell will look for executables in the following order:

	/usr/local/sbin
		- Local system binaries for system administrators (e.g - localtunnel, apache2)
	/usr/local/bin
		- Local user binaries and programs that are manually installed by the system administrator. (E.g - git, python3)
	/usr/sbin
		- System binaries, usually administrative commands that are typically used by the root user or system administrators. (E.g - ifconfig, fsck).
	/usr/bin
		- User binariesâ€”this is where most user-level executable commands and utilities are stored. These are the commands that most users use regularly. (E.g - ls, grep, wc ...)
	/sbin
		- Essential system binaries that are typically only used by the root user for system maintenance and administrative tasks. (E.g - reboot, shutdown)
	/bin
		- Essential command binaries required for the system to boot and run in single-user mode. These binaries are crucial for basic system operation. (E.g - echo, pwd)
	/usr/games
		- Games and interactive programs. Many interactive programs or games are installed here. (E.g - nethack, tetris).
	/usr/local/games
	/snap/bin
		Executables installed via Snap packages. Snap is a package management system that packages software along with its dependencies. (E.g - code, spotify).
	
	Summary of Commands in Each Directory
		
		- System administration -  (e.g., /usr/sbin, /sbin): Tools for system maintenance and configuration.
		
		- User-level commands (e.g., /usr/bin, /bin): Commands like ls, grep, pwd, etc.
		
		- Locally installed tools (e.g., /usr/local/bin, /usr/local/sbin): Programs installed outside the package manager.
		Games (e.g., /usr/games, /usr/local/games): Game executables.

		- Snap packages (e.g., /snap/bin): Commands installed via Snap package manager.